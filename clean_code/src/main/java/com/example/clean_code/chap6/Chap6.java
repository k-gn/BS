package com.example.clean_code.chap6;

/*
	# 객체와 자료구조

	1. 자료 추상화
	- 구현을 외부로 노출하면 안된다.
	- 구현을 감추려면 추상화가 필요하다.
		- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 의미있는 클래스다.
		- 자료는 숨기고 자료를 다루는 함수만 공개한다.
		- 자료를 세세하게 공개히기 보단 추상적으로 공개하는 것이 좋다.
		- 아무 생각없이 get/set 함수를 추가하는 건 좋지 않다.

	2. 자료/객체 비대칭
	- 절차적인 코드는 기존 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
	- 반면 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
	- 절차적인 코드는 새로운 자료구조를 추가하기 어렵다. (모든 함수를 고침)
	- 객체지향 코드는 새로운 함수를 추가하기 어렵다. (모든 클래스 수정)

	3. 디미터의 법칙
	- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.
	- 기차충돌
		- ex.getXXX().getYYY().getZZZ() 같은 구조
		- 조잡한 구조로 피하자.
	- 잡종 구조
		- 절반은 객체, 절반은 자료구조인 경우
		- 새로운 함수나 자료구조를 추가하기 어렵다.
	- 구조체 감추기
		- 객체에게 적당한 임무를 시킨다.
		- 내부 구조를 드러내지 않아야 하고, 모듈에서 자신이 몰라야 하는 여러 객체를 탐색할 필욘 없다.

	4. 자료 전달 객체
		- DTO
		- 이런 클래스에 비즈니스 로직을 추가해 객체로 취급하는 건 좋지 않다.
		- 자료구조로 취급하자.

	- 객체는 동작을 공개하고 자료를 숨긴다.
		- 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기 쉽다.
		- 기존 객체에 새 동작을 추가히기 어렵다.
	- 자료구조는 별다른 동작 없이 자료를 노출한다.
		- 기존 자료구조에 새 동작을 추가하기 쉽다.
		- 기존 함수에 새 자료구조를 추가하기 어렵다.
	- 새 자료 타입을 추가하는 유연성이 필요하면 객체가 적합하다.
	- 새 동작을 추가하는 유연상이 필요하면 자료구조와 절차적인 코드가 적합하다.
	- 편견 없이 직면한 문제에 최선의 해결책을 선택하자.
*/
public class Chap6 {
}
