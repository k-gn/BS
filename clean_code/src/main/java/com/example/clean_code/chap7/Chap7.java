package com.example.clean_code.chap7;

/*
	# 오류 처리

	1. 오류코드 보다 예외를 사용하라
		- 코드가 확실히 깨끗해지고, 독립적으로 분리할 수 있다.

	2. try-catch-finally 문 부터 작성하라
		- 예외가 발생할 코드를 짤 땐 try-catch-finally 부터 시작하는 편이 좋다.
			- try 블록에 무슨일이 생기든지 호출자가 기대하는 상태를 정의하기 쉽다.

	3. unchecked 예외를 사용하라
	 	- checked 예외를 최하단에서 던지면 상위 단계 메서드를 전부 고쳐야 한다.
	 		- OCP 위반
	 		- 모든 함수가 무슨 예외를 던지는지 알아야 하므로 캡슐화 위반
			- 때로는 확인된 예외도 중요하다.

	4. 예외에 의미를 제공하라
		- 예외를 던질 땐 전후 상황을 충분히 덧붙인다.
		- 오류 발생 원인과 위치를 찾기 쉬워진다.
		- 오류 메시지에 정보를 담아 예외와 함께 던진다.
		- 실패한 연산 이름과 실패 유형도 함께 언급하면 더 좋다.
		- 로깅 기능을 사용한다면 기록하기 충분한 정보를 넘긴다.

	5. 호출자를 고려해 예외 클래스를 정의하라
		- 불필요하게 많은 예외 클래스를 잡는다면, 중복도 심해지고 일관성이 없어진다.
			- ex. 외부 라이브러리에 대한 예외 처리 시 해당 라이브러리에 대한 모든 예외를 잡을 경우
		- wrapper class 로 감싼 후 사용하기 좋은 예외를 정의하여 던진다.
			- ex. 외부 라이브러리에 대한 예외 처리를 감싸는 wrapper 클래스를 만든다.
			- 의존성을 줄일 수 있고, 변경에 대한 비용도 줄어든다.
			- 테스트도 쉬워진다.
		- 예외 클래스가 하나만 있어도 충분한 코드가 많다.

	6. 정상 흐름을 정의하라
		- 클래스를 만들거나 객체를 조작해 클라이언트 코드가 예외적인 상황을 처리할 필요가 없도록 할 수 있다.
			- try-catch 를 사용하지 않고 클래스나 객체로 해결
			- try-catch 가 논리를 따라가기 어렵게 만들 때

	7. null 을 반환하지 마라 / null 을 전달하지 마라
		- null 반환/전달은 오류를 유발하는 행위이다.
		- null 인지 확인하는 코드로 가득차게 된다.
		
	- 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
	- 오류 처리를 프로그램 논리와 분리하자.
 */
public class Chap7 {
}
