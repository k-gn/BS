package org.example.movie;

import java.time.DayOfWeek;
import java.time.Duration;
import java.time.LocalTime;

import com.sun.tools.javac.util.List;

/*
    - 생성과 사용의 분리
	- 부적절한 곳에서의 객체 생성은 결합도를 높인다.
    - 동일한 클래스 내에서 객체의 생성과 사용 두가지의 이질적인 목적을 가진 코드가 공존하면 안된다.
    	- 가장 보편적인 방법은 객체를 사용하는 클라이언트가 생성을 책임지는 것
    	- 하지만 클라이언트도 생성과 사용의 책임을 가지게 될 수 있다.

	- Factory 추가하기
		- 객체 생성에 특화된 객체를 Factory 라 부른다.
		- 도메인 개념과 무관한 순수 기술적인 객체
		- 애플리케이션은 도메인 개념들을 초월하는 기계적인 개념들을 필요로 할 수 있다.
		- 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하 등 심각한 문제를 낳을 수 있다.
			 - 도메인 개념의 객체가 아닌 이렇게 설계자가 편의를 위해 임의로 만들어낸 객체에게 책임을 할당하여 문제를 해결해야 한다.
			 - 이러한 임의의 객체를 Pure Fabrication (순수 가공물) 라고 한다. (대부분의 디자인패턴)

	 - 설계자는 도메인 추상화를 기반으로 애플리케이션 로직 설계와 동시에 품질 측면에서 균형을 맞추는 데 필요한 객체를 창조한다.
	 
	 - 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라고 한다.
	 	- 생성자 주입
	 	- setter 주입
	 	- 메서드 인자 주입
	- 의존성을 감추지 말자
		- 의존성 문제 발생 시 컴파일타임이 아닌 런타임에 발견된다.
		- 감추면 이해/인지하기 어렵고, 테스트 코드 작성도 어렵다.
		- 캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다. (단순히 감춘다고 끝이 아니다)
			- 클래스의 사용법을 익히기 위해 내부 구현을 뒤져야 한다면 캡슐화가 무너진 것이다.
			- 퍼블릭 인터페이스 만으로 사용 방법을 이해할 수 있는 코드가 잘 지켜진 캡슐화 코드다.
			- 숨겨진 의존성은 내부 구현을 이해할 것을 강요한다.
		- 명시적으로 의존성을 드러내자.

	- 의존성 역전 원칙
		- 상위 수준 객체는 하위 수준의 변경에 영향을 받으면 안된다.
			- 상위 수준은 하위 수준에 의존해선 안된다.
		- 이것 역시 추상화가 해결해준다!
			- 상위, 하위 모듈 모두 추상화에 의존하면 된다.
			- 추상화는 구체적인 사항에 의존해선 안된다. (그 반대여야 한다.)
			- 하위 수준이 상위 수준을 의존하는 설계
		- 추상화는 별도의 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜야 한다.
			- 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모은다.
			- 불필요한 클래스들을 같은 패키지에 두는 것은 전체적인 빌드 시간을 상승시킨다.
			- ex. movie 는 discountPolicy 를 필요로 하고 있다
				  AmountDiscountPolicy 나 PercentDiscountPolicy 는 컴파일 관계가 없다.
				  따라서 movie 와 discountPolicy 는 같은 패키지에 위치한다.
				  이제 movie 는 다른 패키지(컨텍스트)로 부터 완벽하게 독립되었다.
		    - 상위 수준의 협력 흐름을 재사용하기 위해선 추상화가 제공하는 인터페이스 소유권도 역전시켜야 한다.
		    	- 클라이언트에 추상화(인터페이스)를 위치시킨다.
		    	- 상위 수준에 인터페이스가 위치한다.

	- 유연하고 재사용가능한 설계가 항상 좋은 건 아니다.
		- 단순함과 명확함도 중요하다.
		- 유연하고 재사용가능한 설계는 단순함, 명확함을 버리게 될 가능성이 높다.
		- 유연성은 항상 복잡성을 수반한다.
		- 불필요한 유연성은 복잡성을 낳는다.
		- 유연한 설계는 사람들 간의 커뮤니케이션이 중요하다.

	- 중요한 비즈니스 로직에 대한 책임을 먼저 할당하고 협력의 균형을 맞추는 것이 기술적인 객체 생성보다 우선이다.
	- 도메인 안의 역할, 책임, 협력에 먼저 집중하라.
*/
public class Client {

	private Factory factory;

	public Client(Factory factory) {
		this.factory = factory;
	}

	public Money getAvatarFee() {
		Movie avatar = factory.createAvatarMovie();
		return avatar.getFee();
	}
}
