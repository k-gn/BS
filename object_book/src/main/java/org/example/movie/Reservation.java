package org.example.movie;

public class Reservation {

    /*
        # 퍼블릭 인터페이스 품질에 영향을 미치는 원칙과 기법
        1. 디미터 법칙
            - 부끄럽타는 코드
                - 불필요한 어떤 것도 다른 객체에게 보여주지 않고, 다른 객체의 구현에 의존하지 않는 코드
                - 낮은 결합도
                - 캡슐화 (내부의 구현을 감춤)
                    - 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한
            - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한
            - 아래 조건에 만족하는 인스턴스에만 메시지를 전송하도록 해야한다.
                - this 객체, 메서드의 매개변수, this 의 속성, this 의 속성인 컬렉션 요소, 메서드 내 지역 객체
            - 기차충돌
                - ex. screening.getMovie().getDiscountConditions().xxx()
                - 메시지 수신자의 캡슐화가 무너지고, 메시지 전송자가 수신자의 내부 구현에 강결합 되는 구조
            - 코드 사용 측면에서도 디미터 법칙을 위반한 코드는 사용하기 어렵다.
                - 다른 객체의 내부 구조를 속속히 알고 있어야 한다.
            - 객체는 자기 자신을 책임지는 자율적인 존재라는 사실을 강조 (높은 응집도)
            - 내부 구조를 묻는게 아닌 무언가를 시킴

        2. 묻지말고 시켜라 (TDA)
            - 객체의 상태에 관해서 묻지말고 원하는 것을 시켜야 한다는 것
            - 객체 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 캡슐화 위반
            - 자연스럽게 정보와 행동을 동일 클래스 안에 두게 할 수 있다.

        3. 의도를 드러내는 인터페이스
            - 메서드 이름에 내부 구현 방법을 드러내는 건 좋지 않다.
                - 내부 구현을 정확히 이해하고 사용해야 한다.
                - 메서드 수준에서 캡슐화 위반
                - 사용하는 객체 타입이 추가/변경되면 메서드 이름도 같이 변경된다.
            - 인터페이스는 객체가 어떻게 하는지가 아닌 무엇을 하는지 서술 (기간을 통해 할인 조건 여부를 판단 -> 할인 여부를 판단)
                - 이해하기 쉽고 유연한 코드를 낳는다.
                - 협력안에서 객체의 책임을 고민해야한다.
                - 메서드가 동일한 목적을 가진다는 것을 드러내고, 동일한 타입 계층으로 묶어야 한다.
                    - 클라이언트 의도를 드러낸다.

        - 이 방법들은 절대적인 법칙이 아니다.
        - 설계는 트레이도 오프의 산물이다.
        - 원칙이 언제 유용하고 언제 유용하지 않은지 판단할 수 있어야 한다.
        - 디미터 법칙은 도트(.)를 제한하는 규칙이 아니다.
            - 객체의 내부 구조가 외부로 노출되냐 안되냐가 중요
        - 모든 상황에서 맹목적으로 위임 메서드를 추가하면 객체는 상관없는 책임을 떠안게 되어 낮은 응집도와 높은 결합도를 초래할 수 있다.
            - 클래스는 하나의 변경 원인만을 가져야 한다.
        - 대상이 객체인지 자료구조인지 인지해야 한다. (자료구조는 당연히 내부를 노출해야 한다.)
        - 항상 객체에게 시키는 것이 가능하지 않다.

        4. 명령/쿼리 분리
            - 명령 : 객체의 상태를 수정하는 오퍼레이션
            - 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션
            - 객체의 캡슐화와 재사용성을 높일 수 있다.
            - 명령과 쿼리가 섞이면 실행 결과를 예측하기 힘들다.
                - 내부적으로 부수효과를 가지고 있기 때문이다. -> 버그 위험
            - 메서드가 반환값을 가지고 있는지 여부에 따라 부수효과를 파악할 수 있다.
            - 분리함으로써 어떤 순서로 몇번 호출하건 상관없이 동일한 결과를 반환해줄 수 있다.

         => 책임에 초점을 맞추자.
     */
    private Customer customer;
    private Screening screening;
    private Money fee;
    private int audienceCount;

    public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
        this.customer = customer;
        this.screening = screening;
        this.fee = fee;
        this.audienceCount = audienceCount;
    }
}
