package org.example.movie;

import java.util.ArrayList;
import java.util.List;

/*
    - 중복 코드를 제거하기 위한 추상
    - 차이에 의한 프로그래밍
        - 부모 클래스와 다른 부분만을 추가해 새로운 클래스를 쉽고 빠르게 만드는 방법
        - 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있어서 부모 클래스와 동일한 타입으로 간주할 수 있다.
            => 업캐스팅

    - 상속은 객체지향에서 코드 재사용을 위해 널리 사용되는 기법이다.
    - 하지만 설계에 안좋은 영향을 끼친다.
        - 캡슐화를 위반한다.
            - 상속을 위해선 부모 클래스 구조를 잘 알고 있어야 한다.
            - 즉, 부모 클래스의 구현이 자식 클래스에게 노출된다.
            - 캡슐화 약화는 자식 클래스와 부모 클래스의 강결합을 유도한다.
        - 설계를 유연하지 못하게 한다.
            - 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률이 높다.
            - 과도하게 사용하면 코드 변경이 어려워진다.
            - 부모 클래스와 자식 클래스 관계를 컴파일 시점에 결정하기 때문에 실행 시점에 변경이 불가능하다.

    - 합성을 사용하면 상속의 문제점을 모두 해결할 수 있다.
    - 상속을 사용하지 말라는 것이 아니다.
        - 다형성을 위해 인터페이스를 재사용하는 경우 상속과 합성을 적절히 조합해서 사용한다.
        - 상속 사용 시 고려할 사항
            - 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황인가? (Dog is an Animal)
            - 상속으로 인해 내부 구현을 불필요하게 노출하고 있는 것은 아닌가?
            - 확장하려는 클래스에 결함이 있다면 결함이 내 클래스까지 전파돼도 괜찮은가?

    - 공유하는 상태와 행동의 기본 구현이 존재 -> 추상 클래스
    - 지식의 양이 결합도를 결정한다.
        - 다른 요소에 대해 많은 정보를 알고 있을 수록 결합도가 높아진다.
        - 협력 대상의 필요한 정보 외에 최대한 감추는 것이 중요하다. => 추상화!!
        - 구체 클래스에 직접 의존하는 것은 결합도를 높인다.
        - 다른 객체와 의존해야 하는 이유에 대해 생각하자.
    - 의존성은 명시적이어야 한다.
        - 숨겨진 의존성은 내부 구현을 직접 살펴볼 수 밖에 없다.
        - 의존성이 명시적이지 않으면 재사용하기 위해 내부 구현을 직접 변경해야한다.
        - 퍼블릭 인터페이스를 통해 의존성을 드러내자.
        - 클래스가 다른 클래스에 의존하는 건 문제가 아니다.
            - 의존의 정도가 문제인 것이다.
    - new 는 해롭다.
        - 클래스 사이의 결합도가 극단적으로 높아진다.
        - 구체 클래스로 생성해야 하며 추가로 생성 간 필요한 인자도 같이 알아야한다.
        - 인스턴스 생성 로직과 생성된 인스턴스 사용 로직을 분리하자. (사용과 생성의 책임 분리)
            - 외부에서 전달 받기 (ex. movie 를 사용하는 클라이언트가 생성해서 넘김)
                - 생성 책임을 클라이언트로 옮김
    - 가끔은 클래스 안에 인스턴스를 직접 생성해도 무방하다.
        - 기본적으로 자주 사용하는 객체가 존재하는 경우
            - 생성자 체이닝을 활용해 적절히 교체도 가능하도록 할 수 있다.
            - 메서드 오버로딩도 동일하게 활용 가능
        - 단. 트레이드 오프
            - 결합도와 사용성 사이의 트레이드 오프
        - 팩토리 클래스를 활용해 결합도와 사용성 두가지를 모두 챙길 수도 있다.

    - jdk 표준 클래스에 대한 의존은 해롭지 않다.
        - ex. List, Map, Set ...
        - 변경될 가능성이 0이다.

    - 컨텍스트 확장
        - ex.
            - 할인정책이 없다면 null 로 처리하지 말고 NoneDiscountPolicy 클래스를 생성해 확장
            - 중복 할인 정책이 필요하다면 OverlappedDiscountPolicy 클래스를 생성해 확장
        - 즉, 원하는 기능을 구현한 자식 클래스를 추가하고 전달하기만 하면 된다.
            - movie 객체는 변경되지 않고 재사용할 수 있게 되었다.
            - DiscountPolicy 라는 추상화에 의존하고 생성자를 통해 명시적으로 드러내며 new 같은 직접적인 의존성이 없기 때문이다.

    - 조합 가능한 행동
        - 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로 새로운 행동을 이끌어 낼 수 있는 설계다.
        - how 가 아닌 what 에 집중한다.

    - 개방 폐쇄 원칙 (OCP)
        - 확장에는 열려있고 수정에는 닫혀 있어야 한다.
        - 결합도가 높을 수록 개방 폐쇄 원칙을 따르기 힘들어진다.
        - 즉, 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있어야 한다.
            - 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하자.
            - 추상화에 의존하는 것이 핵심이다.
                - 변하는 것과 변하지 않는 것이 무엇인지 이해하고 이를 추상화
 */
public abstract class DefaultDiscountPolicy implements DiscountPolicy {

    private List<DiscountCondition> conditions = new ArrayList<>();

    public DefaultDiscountPolicy(List<DiscountCondition> conditions) {
        this.conditions = conditions;
    }

    public Money calculateDiscountAmount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }
        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
