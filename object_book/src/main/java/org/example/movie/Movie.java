package org.example.movie;

import java.time.Duration;

/*
    1. 클래스가 아닌 어떤 객체가 필요한지 고민한다.
    2. 객체가 어떤 상태와 행동을 가지는지 고민한다.
    3. 객체를 고립적인 존재가 아닌 협력적인 존재로 인지하고, 유연하고 확장 가능하게 만든다.
    4. 객체를 타입으로 분류하고, 클래스를 구현한다.
    5. 도메인을 구성한 개념이 도움이 된다.
    6. 객체지향이 강력한 이유는 요구사항 분석 초기 단계부터 마지막까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다.
 */
public class Movie {

    private String title;
    private Duration runningTime;

    /*
        - 할인정책을 판단하는 코드가 없고 단지 메시지를 전송할 뿐이다.
        - 상속, 다형성, 추상화 원리가 숨겨져 있다.
        - 코드의 의존성과 실행 시점의 의존성을 서로 다를 수 있다.
            - 트레이드 오프가 존재한다.
                - 코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 코드는 더 유연해지고 확장 가능해진다.
                - 코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 어떤 객체를 의존하는지 찾아야 해서 이해하고 디버깅하기 어려워진다.
                - 즉, 유연성과 가독성 사이에서 고민해야 한다.
        - 누구의 어떤 메서드가 동작할 것인지는 실행 시점에 실제 클래스가 무엇인지에 따라 달라진다. => 다형성
            - 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다.
            - 동일한 메시지를 수신했을 때 객체 타입에 따라 다르게 동작할 수 있다. (지연 바인딩 or 동적 바인딩)
                - 다형적인 협력에 참여하는 객체들은 모두 동일한 인터페이스를 가져야 한다.
                - 인터페이스 상속을 통해 동일한 인터페이스를 물려 받아 인터페이스를 통일할 수 있다.
                    - 즉, 동일한 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다.
                    - 구현 상속과 인터페이스 상속으로 구분된다.
                        - 구현 상속 : 코드 재사용을 목적 (변경애 취약한 코드를 낳을 수 있다.)
                        - 인터페이스 상속 : 다형적인 협력을 위해 인터페이스 공유를 목적

        - 추상화
            - 요구사항의 정책을 높은 수준에서 서술 가능하다.
            - 설계가 좀 더 유연해진다.
                - 기존 구조를 수정하지 않고 새로운 기능을 쉽게 추가/확장할 수 있다.
                - ex. NoneDiscountPolicy
            - 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단히 표현할 수 있다. (필요에 따라 표현의 수준을 조정)
                - 복잡성을 낮춘다.
                - 큰 그림을 쉽게 파악할 수 있다.
     */
    private DiscountPolicy discountPolicy;
    private Money fee;

    private MovieType movieType;

    private Money discountAmount;

    private double discountPercent;

    public Movie(String title, Duration runningTime, DiscountPolicy discountPolicy, Money fee) {
        this.title = title;
        this.runningTime = runningTime;
        this.discountPolicy = discountPolicy;
        this.fee = fee;
    }

    public Money getFee() {
        return fee;
    }

    /*
        - 객체들이 기능을 구현하기 위해 수행한느 상호작용을 "협력" 이라고 한다.
        - 객체가 협력에 참여하기 위해 수행하는 로직은 "책임" 이다.
        - 책임들이 모여 객체가 수행하는 "역할" 을 구성한다.

        - 객체가 참여하는 협력과 책임이 객체를 구성하는 행동과 상태를 결정한다.
        - 협력은 객체를 설계하는데 필요한 일종의 문맥이다.
        - 책임은 하는 것과 아는 것 두 가지 범주로 나뉜다.
        - 협력이 책임을 이끌어내고, 책임이 협력에 참여할 객체를 결정한다.
        - 객체지향 설계는 협력에 필요한 메시지를 찾고, 메시지에 적절한 객체를 선택하는 반복적인 과정을 거친다.
            - 메시지는 수신할 객체의 책임을 결정한다.
            - 어떤 경우엔 응집도와 결합도 관점에서 다른 객체에게 책임을 할당하는 것이 더 적절할 수 있다.
            - 기본적으론 책임을 찾고 책임을 할당할 객체를 찾는 방식 => 책임 주도 설계
                - 자율적인 객체를 만들 가능성이 높은 설계.
                - 자연스럽게 구현이 아닌 책임에 집중할 수 있게 해준다.
        - 책임 할당 시 고려할 점
            - 메시지가 객체를 결정한다.
                - ex. 예매하라, 계산하라
                - 최소한의 인터페이스를 가질 수 있게 된다.
                    - 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있다.
                - 추상적인 인터페이스를 가질 수 있게 된다.
                    - 무엇을 하는지 표현하는데 초점을 맞추는 인터페이스
                    - 어떻게 수행되는지는 노출해선 안된다.
            - 행동이 상태를 결정한다.
                - 항상 협력이라는 문맥 안에서 객체를 생각한다.
                - 협력 안에서 객체들이 무엇을 제공하고 무엇을 얻어야 하는지 고민해야 한다.
                - 상태는 행동을 결정하고 나서야 비로소 결정된다.
                - 협력이 객체의 행동을 결정하고 행동이 상태를 결정하며, 그 행동이 책임이 된다.

        - 역할은 유연하고 재사용 가능한 협력을 얻게 해준다.
        - 메시지를 처리할 수 있는 역할을 찾고, 수행할 객체를 선택한다.
        - ex.
            - 금액 할인과 비율 할인 정책 두가지 모두 할인 요금 계산이란 동일한 책임을 수행한다.
            - 따라서 객체라는 존재를 잠시 지우고 할인 요금 계산이란 대표자를 생각하여 하나로 통합할 수 있다.
            - 이 대표자는 협력안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯이다.
            - 이 슬롯이 역할! => 추상화
        - 요점은 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다.
            - 불필요한 중복을 제거
            - 구체적인 객체들의 타입을 캡슐화
                - 협력을 구체적인 객체가 아닌 추상적인 역할 관점에서 설계
            - 협력이 유연해졌다.
            - 동일한 역할을 수행하는 객체들은 서로 대체가 가능해진다.
            - 추상 클래스와 인터페이스를 사용하여 구현한다.

        - 단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 역할보단 간단하게 객체라고 본다.
        - 여러 종류의 객체들이 참여할 수 있다면 역할이라 부른다.
        - 협력은 역할들의 상호작용으로 구성되고 협력을 구성하기 위해 역할에 적합한 객체가 선택되며 객체는 클래스를 이용해 구현된다.
        - 객체는 여러 협력에 참여하면서 다양한 역할울 수행할 수 있다.
            - 하나의 협력 안에선 일시적으로 오직 하나의 역할만이 보여진다.
            - 동일한 객체라 하더라도 참여하는 협력에 따라 역할이 바뀐다.

        - 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색
        - 역할과 객체를 명확히 구분하는 것은 초반엔 크게 중요하진 않다.
            - 단순 객체로 시작하고 반복적으로 책임과 협력을 정제하면서 역할을 분리해내는 것이 가장 좋다.
        - 가장 중요한 것은 "책임" 이다!
     */
    public Money calculateMovieFee(Screening screening) {
        // 객체에 실제 타입에 따라 실행되는 메서드는 다르다.
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }

    public void changeDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
